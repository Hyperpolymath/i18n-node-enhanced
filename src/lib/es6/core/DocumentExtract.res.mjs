// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Js_math from "@rescript/runtime/lib/es6/Js_math.js";
import * as Stdlib_Exn from "@rescript/runtime/lib/es6/Stdlib_Exn.js";
import * as Stdlib_Array from "@rescript/runtime/lib/es6/Stdlib_Array.js";
import * as Stdlib_Option from "@rescript/runtime/lib/es6/Stdlib_Option.js";
import * as Primitive_exceptions from "@rescript/runtime/lib/es6/Primitive_exceptions.js";

function formatToString(format) {
  switch (format) {
    case "Markdown" :
      return "markdown";
    case "HTML" :
      return "html";
    case "DOCX" :
      return "docx";
    case "ODT" :
      return "odt";
    case "RST" :
      return "rst";
    case "LaTeX" :
      return "latex";
    case "EPUB" :
      return "epub";
    case "PDF" :
      return "pdf";
  }
}

function shellEscape(s) {
  return "'" + s.replaceAll(/'/g, "'\\''") + "'";
}

function getPandocCommand(inputPath, format) {
  let formatStr = formatToString(format);
  let inputArg = shellEscape(inputPath);
  if (format === "PDF") {
    return `pdftotext -layout ` + inputArg + ` -`;
  } else {
    return `pandoc -f ` + formatStr + ` -t plain --wrap=none ` + inputArg;
  }
}

async function runCommand(cmd, args) {
  try {
    let command = (new Deno.Command(cmd, { args: args }));
    let result = await command.output();
    let decoder = new TextDecoder();
    if (result.code === 0) {
      return {
        TAG: "Ok",
        _0: decoder.decode(result.stdout)
      };
    } else {
      return {
        TAG: "Error",
        _0: decoder.decode(result.stderr)
      };
    }
  } catch (raw_e) {
    let e = Primitive_exceptions.internalToException(raw_e);
    if (e.RE_EXN_ID === Stdlib_Exn.$$Error) {
      return {
        TAG: "Error",
        _0: Stdlib_Option.getOr(e._1.message, "Command failed")
      };
    }
    throw e;
  }
}

async function extractFromFile(path, format, param) {
  if (format === "PDF") {
    return await runCommand("pdftotext", [
      "-layout",
      path,
      "-"
    ]);
  }
  let formatStr = formatToString(format);
  return await runCommand("pandoc", [
    "-f",
    formatStr,
    "-t",
    "plain",
    "--wrap=none",
    path
  ]);
}

async function extractFromString(content, format, param) {
  let formatStr = formatToString(format);
  let tempPath = `/tmp/polyglot-extract-` + Js_math.random_int(0, 999999).toString();
  try {
    ((await Deno.writeTextFile(tempPath, content)));
    let result = await runCommand("pandoc", [
      "-f",
      formatStr,
      "-t",
      "plain",
      "--wrap=none",
      tempPath
    ]);
    ((await Deno.remove(tempPath)));
    return result;
  } catch (raw_e) {
    let e = Primitive_exceptions.internalToException(raw_e);
    if (e.RE_EXN_ID === Stdlib_Exn.$$Error) {
      return {
        TAG: "Error",
        _0: Stdlib_Option.getOr(e._1.message, "Extraction failed")
      };
    }
    throw e;
  }
}

function getHunspellCommand(locale) {
  return `hunspell -d ` + locale + ` -a`;
}

async function spellCheck(text, locale) {
  try {
    let words = Stdlib_Array.filterMap(text.split(/[\s]+/), x => x).filter(w => /^[a-zA-Z]+$/.test(w));
    let result = await runCommand("hunspell", [
      "-d",
      locale,
      "-l"
    ]);
    if (result.TAG !== "Ok") {
      return {
        TAG: "Error",
        _0: result._0
      };
    }
    let misspelled = result._0.split("\n").filter(s => s !== "");
    let results = words.map(word => {
      let isCorrect = !misspelled.includes(word);
      return {
        word: word,
        suggestions: [],
        isCorrect: isCorrect
      };
    });
    return {
      TAG: "Ok",
      _0: results
    };
  } catch (raw_e) {
    let e = Primitive_exceptions.internalToException(raw_e);
    if (e.RE_EXN_ID === Stdlib_Exn.$$Error) {
      return {
        TAG: "Error",
        _0: Stdlib_Option.getOr(e._1.message, "Spell check failed")
      };
    }
    throw e;
  }
}

function getTesseractCommand(inputPath, options) {
  let path = shellEscape(inputPath);
  return `tesseract ` + path + ` stdout -l ` + options.lang + ` --psm ` + options.psm.toString() + ` --oem ` + options.oem.toString();
}

async function ocrFromFile(path, options) {
  return await runCommand("tesseract", [
    path,
    "stdout",
    "-l",
    options.lang,
    "--psm",
    options.psm.toString(),
    "--oem",
    options.oem.toString()
  ]);
}

let defaultOptions = {
  preserveFormatting: false,
  extractComments: true,
  ignoreCodeBlocks: true
};

let defaultOcrOptions = {
  lang: "eng",
  psm: 3,
  oem: 3
};

export {
  defaultOptions,
  extractFromFile,
  extractFromString,
  getPandocCommand,
  spellCheck,
  getHunspellCommand,
  defaultOcrOptions,
  ocrFromFile,
  getTesseractCommand,
}
/* No side effect */
