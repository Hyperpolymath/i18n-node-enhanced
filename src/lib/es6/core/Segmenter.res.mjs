// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Locale from "./Locale.res.mjs";
import * as Stdlib_Array from "@rescript/runtime/lib/es6/Stdlib_Array.js";
import * as Stdlib_Option from "@rescript/runtime/lib/es6/Stdlib_Option.js";
import * as Stdlib_String from "@rescript/runtime/lib/es6/Stdlib_String.js";

function make(locale) {
  return {
    locale: Locale.toString(locale)
  };
}

function fromString(s) {
  let base = Stdlib_Option.getOr(s.split("-")[0], s).toLowerCase();
  return {
    locale: base
  };
}

function isCJK(locale) {
  switch (locale) {
    case "ja" :
    case "ko" :
    case "zh" :
      return true;
    default:
      return false;
  }
}

function segmentSentences(t, text) {
  if (isCJK(t.locale)) {
    let result = [];
    let current = {
      contents: ""
    };
    text.split("").forEach(c => {
      current.contents = current.contents + c;
      if (c !== "。" && c !== "！" && c !== "？" && c !== "." && c !== "!" && c !== "?") {
        return;
      }
      let trimmed = current.contents.trim();
      if (trimmed !== "") {
        result.push(trimmed);
      }
      current.contents = "";
    });
    let remaining = current.contents.trim();
    if (remaining !== "") {
      result.push(remaining);
    }
    return result;
  }
  let sentences = [];
  let current$1 = "";
  let chars = text.split("");
  let len = chars.length;
  for (let i = 0; i < len; ++i) {
    let c = chars[i];
    current$1 = current$1 + c;
    if (c === "." || c === "!" || c === "?" || c === "。" || c === "！" || c === "？") {
      let nextChar = (i + 1 | 0) < len ? chars[i + 1 | 0] : undefined;
      let nextNext = (i + 2 | 0) < len ? chars[i + 2 | 0] : undefined;
      let isEnd;
      if (nextChar !== undefined) {
        switch (nextChar) {
          case " " :
            if (nextNext !== undefined) {
              let code = Stdlib_String.charCodeAt(nextNext, 0);
              isEnd = code !== undefined ? code >= 65 && code <= 90 : false;
            } else {
              isEnd = true;
            }
            break;
          case "\n" :
            isEnd = true;
            break;
          default:
            isEnd = false;
        }
      } else {
        isEnd = true;
      }
      if (isEnd) {
        let trimmed = current$1.trim();
        if (trimmed !== "") {
          sentences.push(trimmed);
        }
        current$1 = "";
      }
    }
  }
  let remaining$1 = current$1.trim();
  if (remaining$1 !== "") {
    sentences.push(remaining$1);
  }
  return sentences;
}

function segmentWords(t, text) {
  if (isCJK(t.locale)) {
    return text.split("").filter(c => {
      let trimmed = c.trim();
      if (trimmed !== "") {
        return !/[.,!?。！？、；：\"'()（）「」『』【】]/.test(c);
      } else {
        return false;
      }
    });
  } else {
    return Stdlib_Array.filterMap(text.split(/[\s,;:\"'()\[\]]+/), x => x).map(s => s.replaceAll(/^[.,!?]+|[.,!?]+$/g, "")).filter(s => s !== "");
  }
}

function wordCount(t, text) {
  return segmentWords(t, text).length;
}

function sentenceCount(t, text) {
  return segmentSentences(t, text).length;
}

function charCount(text) {
  return text.split("").filter(c => c.trim() !== "").length;
}

function segmentSentencesWithPositions(t, text) {
  let sentences = segmentSentences(t, text);
  let result = [];
  let pos = {
    contents: 0
  };
  sentences.forEach(sentence => {
    let idx = text.indexOf(sentence, pos.contents);
    if (idx >= 0) {
      result.push({
        text: sentence,
        start: idx,
        end_: idx + sentence.length | 0
      });
      pos.contents = idx + sentence.length | 0;
      return;
    }
  });
  return result;
}

function segmentWordsWithPositions(t, text) {
  let words = segmentWords(t, text);
  let result = [];
  let pos = {
    contents: 0
  };
  words.forEach(word => {
    let idx = text.indexOf(word, pos.contents);
    if (idx >= 0) {
      result.push({
        text: word,
        start: idx,
        end_: idx + word.length | 0
      });
      pos.contents = idx + word.length | 0;
      return;
    }
  });
  return result;
}

export {
  make,
  fromString,
  segmentSentences,
  segmentWords,
  wordCount,
  sentenceCount,
  charCount,
  segmentSentencesWithPositions,
  segmentWordsWithPositions,
}
/* Locale Not a pure module */
