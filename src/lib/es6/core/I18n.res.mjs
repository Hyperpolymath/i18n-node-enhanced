// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Locale from "./Locale.res.mjs";
import * as Plural from "./Plural.res.mjs";
import * as Catalog from "./Catalog.res.mjs";
import * as Stdlib_Array from "@rescript/runtime/lib/es6/Stdlib_Array.js";
import * as Stdlib_Option from "@rescript/runtime/lib/es6/Stdlib_Option.js";
import * as Stdlib_Result from "@rescript/runtime/lib/es6/Stdlib_Result.js";
import * as Belt_MapString from "@rescript/runtime/lib/es6/Belt_MapString.js";

function make() {
  return {
    locales: [],
    defaultLocale: undefined,
    fallbacks: [],
    objectNotation: false,
    missingKeyHandler: undefined
  };
}

function withLocales(builder, locales) {
  builder.locales = locales;
  return builder;
}

function withDefaultLocale(builder, locale) {
  builder.defaultLocale = locale;
  return builder;
}

function withFallback(builder, from, to_) {
  builder.fallbacks = builder.fallbacks.concat([[
      from,
      to_
    ]]);
  return builder;
}

function withObjectNotation(builder, enabled) {
  builder.objectNotation = enabled;
  return builder;
}

function withMissingKeyHandler(builder, handler) {
  builder.missingKeyHandler = handler;
  return builder;
}

function build(builder) {
  let locales = Stdlib_Array.filterMap(builder.locales, Locale.fromString);
  if (locales.length === 0) {
    return {
      TAG: "Error",
      _0: "At least one valid locale is required"
    };
  }
  let s = builder.defaultLocale;
  let defaultLocale = s !== undefined ? Locale.fromString(s) : locales[0];
  if (defaultLocale === undefined) {
    return {
      TAG: "Error",
      _0: "Invalid default locale"
    };
  }
  let fallbacks = Stdlib_Array.reduce(builder.fallbacks, undefined, (acc, param) => {
    let match = Locale.fromString(param[0]);
    let match$1 = Locale.fromString(param[1]);
    if (match !== undefined && match$1 !== undefined) {
      return Belt_MapString.set(acc, Locale.toString(match), match$1);
    } else {
      return acc;
    }
  });
  return {
    TAG: "Ok",
    _0: {
      locales: locales,
      defaultLocale: defaultLocale,
      fallbacks: fallbacks,
      objectNotation: builder.objectNotation,
      missingKeyHandler: builder.missingKeyHandler
    }
  };
}

let Config = {
  make: make,
  withLocales: withLocales,
  withDefaultLocale: withDefaultLocale,
  withFallback: withFallback,
  withObjectNotation: withObjectNotation,
  withMissingKeyHandler: withMissingKeyHandler,
  build: build
};

function make$1(config) {
  let catalogs = Stdlib_Array.reduce(config.locales, undefined, (acc, locale) => Belt_MapString.set(acc, Locale.toString(locale), Catalog.empty(locale)));
  return {
    config: config,
    catalogs: catalogs,
    currentLocale: config.defaultLocale
  };
}

function fromBuilder(builder) {
  return Stdlib_Result.map(build(builder), make$1);
}

function getLocale(i18n) {
  return i18n.currentLocale;
}

function setLocale(i18n, locale) {
  let resolvedLocale;
  if (i18n.config.locales.some(l => Locale.eq(l, locale))) {
    resolvedLocale = locale;
  } else {
    let fallback = Belt_MapString.get(i18n.config.fallbacks, Locale.toString(locale));
    resolvedLocale = fallback !== undefined ? fallback : i18n.config.defaultLocale;
  }
  return {
    config: i18n.config,
    catalogs: i18n.catalogs,
    currentLocale: resolvedLocale
  };
}

function setLocaleString(i18n, locale) {
  let l = Locale.fromString(locale);
  if (l !== undefined) {
    return setLocale(i18n, l);
  } else {
    return i18n;
  }
}

function getCatalog(i18n, locale) {
  return Belt_MapString.get(i18n.catalogs, Locale.toString(locale));
}

function loadTranslations(i18n, locale, json) {
  return Stdlib_Result.map(Catalog.fromJson(locale, json), catalog => {
    let key = Locale.toString(locale);
    let existingCatalog = Stdlib_Option.getOr(Belt_MapString.get(i18n.catalogs, key), Catalog.empty(locale));
    let mergedCatalog = Catalog.merge(existingCatalog, catalog);
    return {
      config: i18n.config,
      catalogs: Belt_MapString.set(i18n.catalogs, key, mergedCatalog),
      currentLocale: i18n.currentLocale
    };
  });
}

let mustachePattern = /\{\{(\w+)\}\}/g;

let sprintfPattern = /%([sdfo%])/g;

function mustache(template, values) {
  return template.replace(mustachePattern, (match, group1, param, param$1) => Stdlib_Option.getOr(values[group1], match));
}

function sprintf(template, args) {
  let index = {
    contents: 0
  };
  return template.replace(sprintfPattern, (match, param, param$1, param$2) => {
    if (match === "%%") {
      return "%";
    }
    let result = Stdlib_Option.getOr(args[index.contents], match);
    index.contents = index.contents + 1 | 0;
    return result;
  });
}

let Interpolate = {
  mustachePattern: mustachePattern,
  sprintfPattern: sprintfPattern,
  mustache: mustache,
  sprintf: sprintf
};

function translate(i18n, key) {
  let locale = i18n.currentLocale;
  let chain = [locale];
  let fallback = Belt_MapString.get(i18n.config.fallbacks, Locale.toString(locale));
  let localeChain = fallback !== undefined ? chain.concat([fallback]) : chain;
  let chain$1 = localeChain.some(l => Locale.eq(l, i18n.config.defaultLocale)) ? localeChain : localeChain.concat([i18n.config.defaultLocale]);
  let result = Stdlib_Array.reduce(chain$1, undefined, (acc, currentLocale) => {
    if (acc !== undefined) {
      return acc;
    } else {
      return Stdlib_Option.flatMap(Belt_MapString.get(i18n.catalogs, Locale.toString(currentLocale)), catalog => Catalog.getString(catalog, key));
    }
  });
  if (result !== undefined) {
    return result;
  }
  let handler = i18n.config.missingKeyHandler;
  if (handler !== undefined) {
    return handler(locale, key);
  } else {
    return key;
  }
}

function translateWith(i18n, key, values) {
  return mustache(translate(i18n, key), values);
}

function translateArgs(i18n, key, args) {
  return sprintf(translate(i18n, key), args);
}

function translatePlural(i18n, singular, plural, count) {
  let locale = i18n.currentLocale;
  let category = Plural.selectForLocale(count, locale);
  let catalogResult = Stdlib_Option.flatMap(Belt_MapString.get(i18n.catalogs, Locale.toString(locale)), catalog => Catalog.get(catalog, singular));
  let template;
  let exit = 0;
  if (catalogResult !== undefined) {
    switch (catalogResult.TAG) {
      case "Simple" :
        template = catalogResult._0;
        break;
      case "Plural" :
        let other = catalogResult.other;
        switch (category) {
          case "Zero" :
            template = Stdlib_Option.getOr(catalogResult.zero, other);
            break;
          case "One" :
            template = Stdlib_Option.getOr(catalogResult.one, other);
            break;
          case "Two" :
            template = Stdlib_Option.getOr(catalogResult.two, other);
            break;
          case "Few" :
            template = Stdlib_Option.getOr(catalogResult.few, other);
            break;
          case "Many" :
            template = Stdlib_Option.getOr(catalogResult.many, other);
            break;
          case "Other" :
            template = other;
            break;
        }
        break;
      case "Nested" :
        exit = 1;
        break;
    }
  } else {
    exit = 1;
  }
  if (exit === 1) {
    template = category === "One" ? singular : plural;
  }
  return template.replace(/%[sd]/, count.toString());
}

function getLocales(i18n) {
  return i18n.config.locales;
}

function getDefaultLocale(i18n) {
  return i18n.config.defaultLocale;
}

function hasKey(i18n, key) {
  let locale = i18n.currentLocale;
  return Stdlib_Option.getOr(Stdlib_Option.map(Belt_MapString.get(i18n.catalogs, Locale.toString(locale)), catalog => Catalog.has(catalog, key)), false);
}

function getAllKeys(i18n) {
  let locale = i18n.currentLocale;
  return Stdlib_Option.getOr(Stdlib_Option.map(Belt_MapString.get(i18n.catalogs, Locale.toString(locale)), Catalog.keys), []);
}

function exportCatalog(i18n, locale) {
  return Stdlib_Option.map(Belt_MapString.get(i18n.catalogs, Locale.toString(locale)), Catalog.toJson);
}

let __ = translate;

let __n = translatePlural;

export {
  Config,
  make$1 as make,
  fromBuilder,
  getLocale,
  setLocale,
  setLocaleString,
  getCatalog,
  loadTranslations,
  Interpolate,
  translate,
  translateWith,
  translateArgs,
  translatePlural,
  __,
  __n,
  getLocales,
  getDefaultLocale,
  hasKey,
  getAllKeys,
  exportCatalog,
}
/* Locale Not a pure module */
