// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Js_dict from "@rescript/runtime/lib/es6/Js_dict.js";
import * as Js_json from "@rescript/runtime/lib/es6/Js_json.js";
import * as Stdlib_Array from "@rescript/runtime/lib/es6/Stdlib_Array.js";
import * as Stdlib_Option from "@rescript/runtime/lib/es6/Stdlib_Option.js";
import * as Belt_MapString from "@rescript/runtime/lib/es6/Belt_MapString.js";
import * as Belt_SetString from "@rescript/runtime/lib/es6/Belt_SetString.js";

function empty(locale) {
  return {
    locale: locale,
    translations: undefined,
    metadata: {
      version: undefined,
      lastModified: undefined,
      source: undefined
    }
  };
}

function get(catalog, key) {
  let parts = key.split(".");
  let _translations = catalog.translations;
  let _path = parts;
  while (true) {
    let path = _path;
    let translations = _translations;
    let len = path.length;
    if (len === 0) {
      return;
    }
    if (len === 1) {
      return Stdlib_Option.flatMap(path[0], single => Belt_MapString.get(translations, single));
    }
    let head = path[0];
    if (head === undefined) {
      return;
    }
    let rest = path.slice(1);
    let match = Belt_MapString.get(translations, head);
    if (match === undefined) {
      return;
    }
    switch (match.TAG) {
      case "Simple" :
      case "Plural" :
        return;
      case "Nested" :
        _path = rest;
        _translations = match._0;
        continue;
    }
  };
}

function getString(catalog, key) {
  let match = get(catalog, key);
  if (match === undefined) {
    return;
  }
  switch (match.TAG) {
    case "Simple" :
      return match._0;
    case "Plural" :
      return match.other;
    case "Nested" :
      return;
  }
}

function set(catalog, key, value) {
  let parts = key.split(".");
  let updateNested = (translations, path, value) => {
    let len = path.length;
    if (len === 0) {
      return translations;
    }
    if (len === 1) {
      let single = path[0];
      if (single !== undefined) {
        return Belt_MapString.set(translations, single, value);
      } else {
        return translations;
      }
    }
    let head = path[0];
    if (head === undefined) {
      return translations;
    }
    let rest = path.slice(1);
    let match = Belt_MapString.get(translations, head);
    let existing;
    if (match !== undefined) {
      switch (match.TAG) {
        case "Simple" :
        case "Plural" :
          existing = undefined;
          break;
        case "Nested" :
          existing = match._0;
          break;
      }
    } else {
      existing = undefined;
    }
    let updated = updateNested(existing, rest, value);
    return Belt_MapString.set(translations, head, {
      TAG: "Nested",
      _0: updated
    });
  };
  let init = catalog.metadata;
  return {
    locale: catalog.locale,
    translations: updateNested(catalog.translations, parts, value),
    metadata: {
      version: init.version,
      lastModified: Date.now(),
      source: init.source
    }
  };
}

function has(catalog, key) {
  return Stdlib_Option.isSome(get(catalog, key));
}

function keys(catalog) {
  let collect = (translations, prefix) => Belt_MapString.toArray(translations).flatMap(param => {
    let value = param[1];
    let key = param[0];
    let fullKey = prefix === "" ? key : prefix + `.` + key;
    switch (value.TAG) {
      case "Simple" :
      case "Plural" :
        return [fullKey];
      case "Nested" :
        return collect(value._0, fullKey);
    }
  });
  return collect(catalog.translations, "");
}

function merge(base, overlay) {
  let mergeTranslations = (a, b) => {
    let allKeys = Belt_SetString.toArray(Belt_SetString.fromArray(Belt_MapString.keysToArray(a).concat(Belt_MapString.keysToArray(b))));
    return Stdlib_Array.reduce(allKeys, undefined, (acc, key) => {
      let match = Belt_MapString.get(a, key);
      let match$1 = Belt_MapString.get(b, key);
      let value = match$1 !== undefined ? match$1 : (
          match !== undefined ? match : ({
              TAG: "Simple",
              _0: ""
            })
        );
      return Belt_MapString.set(acc, key, value);
    });
  };
  return {
    locale: overlay.locale,
    translations: mergeTranslations(base.translations, overlay.translations),
    metadata: overlay.metadata
  };
}

function fromJson(locale, json) {
  let parseValue = json => {
    let s = Js_json.classify(json);
    if (typeof s !== "object") {
      return;
    }
    switch (s.TAG) {
      case "JSONString" :
        return {
          TAG: "Simple",
          _0: s._0
        };
      case "JSONObject" :
        let obj = s._0;
        let hasPlural = Stdlib_Option.isSome(Js_dict.get(obj, "other"));
        if (hasPlural) {
          let getStr = key => Stdlib_Option.flatMap(Js_dict.get(obj, key), v => {
            let s = Js_json.classify(v);
            if (typeof s !== "object" || s.TAG !== "JSONString") {
              return;
            } else {
              return s._0;
            }
          });
          let other = getStr("other");
          if (other !== undefined) {
            return {
              TAG: "Plural",
              zero: getStr("zero"),
              one: getStr("one"),
              two: getStr("two"),
              few: getStr("few"),
              many: getStr("many"),
              other: other
            };
          } else {
            return;
          }
        }
        let nested = Stdlib_Array.reduce(Js_dict.entries(obj), undefined, (acc, param) => {
          let v = parseValue(param[1]);
          if (v !== undefined) {
            return Belt_MapString.set(acc, param[0], v);
          } else {
            return acc;
          }
        });
        return {
          TAG: "Nested",
          _0: nested
        };
      default:
        return;
    }
  };
  let obj = Js_json.classify(json);
  if (typeof obj !== "object") {
    return {
      TAG: "Error",
      _0: "Expected JSON object at root"
    };
  }
  if (obj.TAG !== "JSONObject") {
    return {
      TAG: "Error",
      _0: "Expected JSON object at root"
    };
  }
  let translations = Stdlib_Array.reduce(Js_dict.entries(obj._0), undefined, (acc, param) => {
    let v = parseValue(param[1]);
    if (v !== undefined) {
      return Belt_MapString.set(acc, param[0], v);
    } else {
      return acc;
    }
  });
  return {
    TAG: "Ok",
    _0: {
      locale: locale,
      translations: translations,
      metadata: {
        version: undefined,
        lastModified: Date.now(),
        source: undefined
      }
    }
  };
}

function toJson(catalog) {
  let valueToJson = value => {
    switch (value.TAG) {
      case "Simple" :
        return value._0;
      case "Plural" :
        let obj = {};
        Stdlib_Option.forEach(value.zero, v => {
          obj["zero"] = v;
        });
        Stdlib_Option.forEach(value.one, v => {
          obj["one"] = v;
        });
        Stdlib_Option.forEach(value.two, v => {
          obj["two"] = v;
        });
        Stdlib_Option.forEach(value.few, v => {
          obj["few"] = v;
        });
        Stdlib_Option.forEach(value.many, v => {
          obj["many"] = v;
        });
        obj["other"] = value.other;
        return obj;
      case "Nested" :
        let obj$1 = {};
        Belt_MapString.forEach(value._0, (key, value) => {
          obj$1[key] = valueToJson(value);
        });
        return obj$1;
    }
  };
  let obj = {};
  Belt_MapString.forEach(catalog.translations, (key, value) => {
    obj[key] = valueToJson(value);
  });
  return obj;
}

export {
  empty,
  get,
  getString,
  set,
  has,
  keys,
  merge,
  fromJson,
  toJson,
}
/* No side effect */
