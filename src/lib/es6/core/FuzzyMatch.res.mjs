// Generated by ReScript, PLEASE EDIT WITH CARE

import * as Stdlib_Array from "@rescript/runtime/lib/es6/Stdlib_Array.js";

function make() {
  return {
    threshold: 0.6,
    maxResults: 10
  };
}

function withThreshold(config, threshold) {
  return {
    threshold: Math.min(1.0, Math.max(0.0, threshold)),
    maxResults: config.maxResults
  };
}

function withMaxResults(config, maxResults) {
  return {
    threshold: config.threshold,
    maxResults: Math.max(1, maxResults)
  };
}

function levenshteinDistance(a, b) {
  let aChars = a.split("");
  let bChars = b.split("");
  let aLen = aChars.length;
  let bLen = bChars.length;
  if (aLen === 0) {
    return bLen;
  }
  if (bLen === 0) {
    return aLen;
  }
  let matrix = Stdlib_Array.make(aLen + 1 | 0, Stdlib_Array.make(bLen + 1 | 0, 0));
  for (let i = 0; i <= aLen; ++i) {
    matrix[i] = Stdlib_Array.make(bLen + 1 | 0, 0);
    let row = matrix[i];
    row[0] = i;
  }
  for (let j = 0; j <= bLen; ++j) {
    let row0 = matrix[0];
    row0[j] = j;
  }
  for (let i$1 = 1; i$1 <= aLen; ++i$1) {
    for (let j$1 = 1; j$1 <= bLen; ++j$1) {
      let aChar = aChars[i$1 - 1 | 0];
      let bChar = bChars[j$1 - 1 | 0];
      let cost = aChar === bChar ? 0 : 1;
      let rowI = matrix[i$1];
      let rowIM1 = matrix[i$1 - 1 | 0];
      let val1 = rowIM1[j$1] + 1 | 0;
      let val2 = rowI[j$1 - 1 | 0] + 1 | 0;
      let val3 = rowIM1[j$1 - 1 | 0] + cost | 0;
      rowI[j$1] = Math.min(Math.min(val1, val2), val3);
    }
  }
  let lastRow = matrix[aLen];
  return lastRow[bLen];
}

function damerauLevenshteinDistance(a, b) {
  let aChars = a.split("");
  let bChars = b.split("");
  let aLen = aChars.length;
  let bLen = bChars.length;
  if (aLen === 0) {
    return bLen;
  }
  if (bLen === 0) {
    return aLen;
  }
  let matrix = Stdlib_Array.make(aLen + 1 | 0, Stdlib_Array.make(bLen + 1 | 0, 0));
  for (let i = 0; i <= aLen; ++i) {
    matrix[i] = Stdlib_Array.make(bLen + 1 | 0, 0);
    let row = matrix[i];
    row[0] = i;
  }
  for (let j = 0; j <= bLen; ++j) {
    let row0 = matrix[0];
    row0[j] = j;
  }
  for (let i$1 = 1; i$1 <= aLen; ++i$1) {
    for (let j$1 = 1; j$1 <= bLen; ++j$1) {
      let aCharI = aChars[i$1 - 1 | 0];
      let bCharJ = bChars[j$1 - 1 | 0];
      let cost = aCharI === bCharJ ? 0 : 1;
      let rowI = matrix[i$1];
      let rowIM1 = matrix[i$1 - 1 | 0];
      let val1 = rowIM1[j$1] + 1 | 0;
      let val2 = rowI[j$1 - 1 | 0] + 1 | 0;
      let val3 = rowIM1[j$1 - 1 | 0] + cost | 0;
      rowI[j$1] = Math.min(Math.min(val1, val2), val3);
      if (i$1 > 1 && j$1 > 1) {
        let bCharJM1 = bChars[j$1 - 2 | 0];
        let aCharIM1 = aChars[i$1 - 2 | 0];
        if (aCharI === bCharJM1 && aCharIM1 === bCharJ) {
          let rowIM2 = matrix[i$1 - 2 | 0];
          let current = rowI[j$1];
          let trans = rowIM2[j$1 - 2 | 0] + cost | 0;
          rowI[j$1] = Math.min(current, trans);
        }
      }
    }
  }
  let lastRow = matrix[aLen];
  return lastRow[bLen];
}

function similarity(a, b) {
  let dist = levenshteinDistance(a, b);
  let maxLen = Math.max(a.length, b.length);
  if (maxLen === 0) {
    return 1.0;
  } else {
    return 1.0 - dist / maxLen;
  }
}

function findMatches(config, query, corpus) {
  let queryLower = query.toLowerCase();
  let matches = corpus.map(text => {
    let textLower = text.toLowerCase();
    let dist = levenshteinDistance(queryLower, textLower);
    let maxLen = Math.max(queryLower.length, textLower.length);
    let score = maxLen === 0 ? 1.0 : 1.0 - dist / maxLen;
    return {
      text: text,
      score: score,
      distance: dist
    };
  }).filter(m => m.score >= config.threshold).toSorted((a, b) => b.score - a.score);
  return matches.slice(0, config.maxResults);
}

function bestMatch(config, query, candidates) {
  let matches = findMatches(config, query, candidates);
  return matches[0];
}

function agrep(pattern, text, maxDistance) {
  return levenshteinDistance(pattern, text) <= maxDistance;
}

function ngramSimilarity(a, b, n) {
  let aChars = a.toLowerCase().split("");
  let bChars = b.toLowerCase().split("");
  if (aChars.length < n || bChars.length < n) {
    if (a.toLowerCase() === b.toLowerCase()) {
      return 1.0;
    } else {
      return 0.0;
    }
  }
  let getNgrams = chars => {
    let result = [];
    for (let i = 0, i_finish = chars.length - n | 0; i <= i_finish; ++i) {
      let ngram = chars.slice(i, i + n | 0).join("");
      result.push(ngram);
    }
    return result;
  };
  let aNgrams = getNgrams(aChars);
  let bNgrams = getNgrams(bChars);
  let aSet = new Set(aNgrams);
  let bSet = new Set(bNgrams);
  let intersection = aSet.values().toArray().filter(x => bSet.has(x));
  let union = aSet.union(bSet);
  let unionSize = union.size;
  if (unionSize === 0) {
    return 1.0;
  } else {
    return intersection.length / unionSize;
  }
}

function generateNgrams(text, n) {
  let chars = text.toLowerCase().split("");
  if (chars.length < n) {
    return [text.toLowerCase()];
  }
  let result = [];
  for (let i = 0, i_finish = chars.length - n | 0; i <= i_finish; ++i) {
    let ngram = chars.slice(i, i + n | 0).join("");
    result.push(ngram);
  }
  return result;
}

export {
  make,
  withThreshold,
  withMaxResults,
  levenshteinDistance,
  damerauLevenshteinDistance,
  similarity,
  findMatches,
  bestMatch,
  agrep,
  ngramSimilarity,
  generateNgrams,
}
/* No side effect */
